# Java 21 Virtual Threads (Project Loom)

## 1. 개요
Java 21에서 정식 도입된 **가상 스레드(Virtual Thread)**는 기존의 자바 동시성 모델을 완전히 뒤바꾸는 혁신적인 기능입니다.
기존에는 OS 스레드와 1:1로 매핑되는 무거운 "플랫폼 스레드"를 사용했지만, 가상 스레드는 JVM 내부에서 관리되는 경량 스레드입니다.

## 2. 핵심 차이점

| 특징 | 플랫폼 스레드 (기존) | 가상 스레드 (New) |
| :--- | :--- | :--- |
| **매핑** | OS 스레드와 1:1 | OS 스레드와 N:M (수천 개가 1개 OS 스레드 공유) |
| **생성 비용** | 비쌈 (메모리 1MB~2MB) | 매우 저렴 (메모리 수 KB) |
| **개수 제한** | 수천 개 (OS 리소스 한계) | 수백만 개 가능 |
| **블로킹 시** | OS 스레드도 같이 멈춤 (낭비) | **OS 스레드를 놓고(Yield) 다른 가상 스레드가 실행됨** |

## 3. Spring Boot 3.2+ 설정
아주 간단합니다. `application.yml`에 다음 한 줄만 추가하면 톰캣이 가상 스레드를 사용합니다.
```yaml
spring:
  threads:
    virtual:
      enabled: true
```

## 4. 실습 내용

### 목표
1000개의 동시 요청을 보냈을 때, 서버가 어떻게 처리하는지 확인합니다.
각 요청은 1초간 `Thread.sleep()`을 수행합니다.

### 예상 결과
- **기존 방식 (max-threads=200):** 
  - 200개 처리 -> 1초 대기 -> 200개 처리 -> ... 
  - 총 5초 이상 소요됨.
- **가상 스레드 방식:**
  - 1000개 요청을 거의 동시에 받음.
  - 블로킹 구간에서 스레드를 스위칭하며 처리.
  - **총 1초 + @ (아주 짧은 시간) 소요됨.**

## 5. 주의사항 (Pinning Issue)
가상 스레드가 만능은 아닙니다. `synchronized` 블록 내부에서 블로킹 연산(I/O 등)을 수행하면, OS 스레드를 놓아주지 못하고 붙잡고 있는 **Pinning(고정)** 현상이 발생하여 성능이 급격히 저하됩니다.
-> 해결책: `ReentrantLock`을 사용하세요.
